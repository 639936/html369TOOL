<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Processor & Standardizer</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #2a2a2e;
            --secondary-color: #3a3a40;
            --text-color: #e0e0e0;
            --accent-color: #4a90e2;
            --success-color: #7ed321;
            --error-color: #d0021b;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header, main {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3, h4 {
            color: var(--accent-color);
        }

        h2, h3 {
             border-bottom: 2px solid var(--secondary-color);
             padding-bottom: 10px;
        }
        
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .settings-panel, .file-panel {
            background-color: var(--primary-color);
            padding: 20px;
            border-radius: 8px;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }

        details {
            background-color: var(--primary-color);
            border: 1px solid var(--secondary-color);
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            color: var(--accent-color);
        }

        textarea {
            width: 100%;
            box-sizing: border-box;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            padding: 10px;
            min-height: 100px;
            font-size: 14px;
            resize: vertical;
            margin-top: 10px;
        }

        #apiKeysInput, #promptInput { min-height: 100px; }
        #mainTextInput { min-height: 250px; } /* Giảm chiều cao mặc định một chút */
        .output-area textarea { min-height: 100px; }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #357abd; }
        button.secondary { background-color: var(--secondary-color); }
        button.secondary:hover { background-color: #555; }
        button.danger { background-color: var(--error-color); }
        button.danger:hover { background-color: #a00; }

        .button-group { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        .input-group { display: flex; align-items: center; gap: 15px; margin-top: 10px; flex-wrap: wrap; }
        .input-group label { font-weight: bold; }
        .input-group input { background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--secondary-color); border-radius: 4px; padding: 8px; }
        
        .options-group { margin-bottom: 15px; padding: 10px; background-color: var(--secondary-color); border-radius: 4px; }
        .options-group .option-item { display: block; margin-bottom: 8px; }
        .options-group label { margin-left: 8px; cursor: pointer; }
        .options-group input[type="checkbox"] { transform: scale(1.2); vertical-align: middle; }

        .drop-zone {
            border: 2px dashed var(--secondary-color);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            margin-top: 15px;
        }
        .drop-zone.dragover { background-color: var(--secondary-color); border-color: var(--accent-color); }
        .file-input-hidden { display: none; }

        .chunk-list, .file-list {
            list-style-type: none;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .chunk-list li, .file-list li {
            background-color: var(--secondary-color);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: monospace;
        }
        .chunk-list li::before, .file-list li::before { font-weight: bold; }
        .status-pending::before { content: '⏳'; }
        .status-processing::before { content: '⚙️'; animation: spin 1s linear infinite; }
        .status-success::before { content: '✅'; }
        .status-failed::before { content: '❌'; }
        
        .output-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .output-area { display: flex; flex-direction: column; gap: 10px; }
        .output-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap;}
        #progress-counter, #totalInputChars { font-weight: bold; color: var(--accent-color); }
        hr { border: none; border-top: 2px solid var(--secondary-color); margin: 40px 0; }

        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <header>
        <h1>Gemini Processor & Standardizer</h1>
    </header>
    <main>
        <div>
            <a href="index.html">Quay về</a>
        </div>
        <!-- ==================== GEMINI PROCESSING SECTION ==================== -->
        <section>
            <h2>Công cụ xử lý Gemini</h2>
            <div class="grid-container">
                <div class="settings-panel">
                    <h3>Cài đặt</h3>
                    <details>
                        <summary>API Keys</summary>
                        <textarea id="apiKeysInput" placeholder="Dán mỗi API Key trên một dòng..."></textarea>
                    </details>
                    <details>
                        <summary>Prompt</summary>
                        <textarea id="promptInput"></textarea>
                    </details>
                </div>
                <div class="file-panel">
                    <h3>Bước 1: Nhập liệu</h3>
                    <textarea id="mainTextInput" placeholder="Dán toàn bộ văn bản vào đây..."></textarea>
                    <p style="margin-top: 5px; text-align: right;">Tổng ký tự: <span id="totalInputChars">0</span></p>
                    <div id="drop-zone" class="drop-zone">
                        Hoặc kéo thả/chọn file (.txt, .html)
                        <input type="file" id="fileInput" class="file-input-hidden" multiple accept=".txt,.html,text/plain,text/html">
                    </div>
                </div>
            </div>

            <div class="full-width settings-panel">
                <h3>Bước 2: Tách & Gộp đoạn</h3>
                <div class="input-group">
                    <div>
                        <label for="separatorInput">Ký tự tách đoạn:</label>
                        <input type="text" id="separatorInput" value="\n\n" placeholder="\n\n" style="width: 80px;">
                    </div>
                    <div>
                        <label for="mergeCountInput">Gộp mỗi:</label>
                        <input type="number" id="mergeCountInput" value="1" min="1" style="width: 60px;">
                        <span>đoạn</span>
                    </div>
                    <button id="prepareChunksBtn">Chuẩn bị các đoạn</button>
                </div>
                <p>Danh sách các đoạn cần xử lý <span id="progress-counter"></span></p>
                <ul id="chunkList" class="chunk-list"></ul>
            </div>

            <div class="full-width button-group">
                <h3>Bước 3: Xử lý</h3>
                <button id="startBtn">Bắt đầu xử lý</button>
                <button id="resumeBtn" class="secondary">Tiếp tục xử lý đoạn lỗi</button>
                <button id="saveStateBtn">Lưu phiên làm việc</button>
                <button id="clearStateBtn" class="danger">Xóa và làm mới</button>
            </div>

            <div class="full-width output-grid">
                <div class="output-area">
                    <div class="output-header"><h4>Kết quả: Tên Riêng</h4><div class="button-group"><button class="secondary" onclick="copyToClipboard('outputName')">Copy</button><button class="secondary" onclick="downloadAsFile('outputName', 'name.txt')">Tải về</button></div></div>
                    <details>
                        <summary>review</summary>
                        <textarea id="outputName" placeholder="..."></textarea>
                    </details>
                </div>
                <div class="output-area">
                    <div class="output-header"><h4>Kết quả: Việt Phrase</h4><div class="button-group"><button class="secondary" onclick="copyToClipboard('outputVp')">Copy</button><button class="secondary" onclick="downloadAsFile('outputVp', 'vp.txt')">Tải về</button></div></div>
                    <details>
                        <summary>review</summary>
                        <textarea id="outputVp" placeholder="..."></textarea>
                    </details>
                </div>
                <div class="output-area">
                    <div class="output-header"><h4>Kết quả: Luật Nhân</h4><div class="button-group"><button class="secondary" onclick="copyToClipboard('outputRule')">Copy</button><button class="secondary" onclick="downloadAsFile('outputRule', 'rule.txt')">Tải về</button></div></div>
                    <details>
                        <summary>review</summary>
                        <textarea id="outputRule" placeholder="..."></textarea>
                    </details>
                </div>
            </div>
        </section>

        <hr>

        <!-- ==================== STANDARDIZER SECTION ==================== -->
        <section>
            <h2>Công cụ Chuẩn hoá Dữ liệu</h2>
            <div class="options-group">
                <div class="option-item">
                    <input type="checkbox" id="standardizer-remove-special-chars" checked>
                    <label for="standardizer-remove-special-chars">Xóa dòng chứa ký tự đặc biệt khi chuẩn hóa</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="standardizer-allow-curly-braces" checked>
                    <label for="standardizer-allow-curly-braces">Bỏ qua ký tự <code>{}</code> khi xóa dòng đặc biệt (cho file Rule)</label>
                </div>
            </div>
            <details open>
                <summary>1. Chuẩn hóa file vừa được tạo</summary>
                <p>Chức năng này sẽ lấy dữ liệu từ 3 ô kết quả ở trên và áp dụng các bộ lọc nâng cao.</p>
                <div class="button-group">
                     <button id="standardizeGeneratedBtn">Bắt đầu chuẩn hóa</button>
                </div>
                <div class="output-grid" style="margin-top: 15px;">
                    <div class="output-area">
                        <div class="output-header"><h4>Name đã chuẩn hóa</h4><div class="button-group"><button class="secondary" onclick="copyToClipboard('reviewName')">Copy</button><button class="secondary" onclick="downloadAsFile('reviewName', 'name_std.txt')">Tải về</button></div></div>
                        <textarea id="reviewName" placeholder="Hiển thị một phần kết quả..."></textarea>
                    </div>
                    <div class="output-area">
                        <div class="output-header"><h4>VP đã chuẩn hóa</h4><div class="button-group"><button class="secondary" onclick="copyToClipboard('reviewVp')">Copy</button><button class="secondary" onclick="downloadAsFile('reviewVp', 'vp_std.txt')">Tải về</button></div></div>
                        <textarea id="reviewVp" placeholder="Hiển thị một phần kết quả..."></textarea>
                    </div>
                    <div class="output-area">
                        <div class="output-header"><h4>Rule đã chuẩn hóa</h4><div class="button-group"><button class="secondary" onclick="copyToClipboard('reviewRule')">Copy</button><button class="secondary" onclick="downloadAsFile('reviewRule', 'rule_std.txt')">Tải về</button></div></div>
                        <textarea id="reviewRule" placeholder="Hiển thị một phần kết quả..."></textarea>
                    </div>
                </div>
            </details>

            <details>
                <summary>2. Chuẩn hóa file Name tùy chỉnh</summary>
                <div id="standardizer-name">
                    <textarea placeholder="Dán nội dung Name vào đây..."></textarea>
                    <div class="drop-zone">Kéo thả hoặc chọn file Name (.txt)</div>
                    <input type="file" class="file-input-hidden" multiple accept=".txt,text/plain">
                    <ul class="file-list"></ul>
                    <div class="button-group"><button>Chuẩn hoá Name</button></div>
                    <div class="output-area" style="margin-top:20px;">
                        <div class="output-header"><h4>Kết quả Name</h4><div class="button-group"><button class="secondary">Copy</button><button class="secondary">Tải về</button></div></div>
                        <textarea placeholder="Kết quả Name đã chuẩn hoá..."></textarea>
                    </div>
                </div>
            </details>

            <details>
                <summary>3. Chuẩn hóa file VP tùy chỉnh</summary>
                <div id="standardizer-vp">
                    <textarea placeholder="Dán nội dung VP vào đây..."></textarea>
                    <div class="drop-zone">Kéo thả hoặc chọn file VP (.txt)</div>
                    <input type="file" class="file-input-hidden" multiple accept=".txt,text/plain">
                    <ul class="file-list"></ul>
                    <div class="button-group"><button>Chuẩn hoá VP</button></div>
                    <div class="output-area" style="margin-top:20px;">
                        <div class="output-header"><h4>Kết quả VP</h4><div class="button-group"><button class="secondary">Copy</button><button class="secondary">Tải về</button></div></div>
                        <textarea placeholder="Kết quả VP đã chuẩn hoá..."></textarea>
                    </div>
                </div>
            </details>

            <details>
                <summary>4. Chuẩn hóa file Rule tùy chỉnh</summary>
                 <div id="standardizer-rule">
                    <textarea placeholder="Dán nội dung Rule vào đây..."></textarea>
                    <div class="drop-zone">Kéo thả hoặc chọn file Rule (.txt)</div>
                    <input type="file" class="file-input-hidden" multiple accept=".txt,text/plain">
                    <ul class="file-list"></ul>
                    <div class="button-group"><button>Chuẩn hoá Rule</button></div>
                    <div class="output-area" style="margin-top:20px;">
                        <div class="output-header"><h4>Kết quả Rule</h4><div class="button-group"><button class="secondary">Copy</button><button class="secondary">Tải về</button></div></div>
                        <textarea placeholder="Kết quả Rule đã chuẩn hoá..."></textarea>
                    </div>
                </div>
            </details>
        </section>
    <div>
            <a href="CreatVPNamesNSFW.html">Reload page</a>
        </div>
    </main>

    <script>
        // --- DOM Elements ---
        const apiKeysInput = document.getElementById('apiKeysInput');
        const promptInput = document.getElementById('promptInput');
        const mainTextInput = document.getElementById('mainTextInput');
        const totalInputChars = document.getElementById('totalInputChars');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('fileInput');
        const separatorInput = document.getElementById('separatorInput');
        const mergeCountInput = document.getElementById('mergeCountInput');
        const prepareChunksBtn = document.getElementById('prepareChunksBtn');
        const chunkListElem = document.getElementById('chunkList');
        const startBtn = document.getElementById('startBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const saveStateBtn = document.getElementById('saveStateBtn');
        const clearStateBtn = document.getElementById('clearStateBtn');
        const progressCounter = document.getElementById('progress-counter');
        const outputName = document.getElementById('outputName');
        const outputVp = document.getElementById('outputVp');
        const outputRule = document.getElementById('outputRule');

        // Standardizer DOM Elements
        const standardizeGeneratedBtn = document.getElementById('standardizeGeneratedBtn');
        const reviewName = document.getElementById('reviewName');
        const reviewVp = document.getElementById('reviewVp');
        const reviewRule = document.getElementById('reviewRule');
        const removeSpecialCharsToggle = document.getElementById('standardizer-remove-special-chars');
        const allowCurlyBracesToggle = document.getElementById('standardizer-allow-curly-braces'); // New Checkbox

        
        // --- State Variables ---
        let fullInputText = ''; 
        const INPUT_PREVIEW_LENGTH = 5000;
        let chunksToProcess = [];
        let isProcessing = false;
        const DEFAULT_PROMPT = `Bạn là một AI chuyên gia về dịch thuật và xử lý ngôn ngữ, được huấn luyện để phân tích văn bản truyện tiên hiệp, kiếm hiệp, huyền huyễn.
Mục tiêu: Phân tích văn bản tiếng Trung được cung cấp, sau đó trích xuất, phân loại và dịch các thành phần theo các quy tắc nghiêm ngặt dưới đây.
Bước 1: Hiểu rõ các loại dữ liệu cần trích xuất
Bạn phải phân loại các từ/cụm từ tiếng Trung tìm được vào BA nhóm sau đây, dựa trên ĐỊNH NGHĨA, YÊU CẦU CỦA TÔI và VÍ DỤ:
Nhóm 1: tên
ĐỊNH NGHĨA: Bao gồm tên riêng (người, địa danh, môn phái, công pháp, vũ khí) và các danh từ chung ĐƠN LẺ hoặc cụm danh từ CỐ ĐỊNH.
YÊU CẦU CỦA TÔI: Chúng được dịch trực tiếp sang Hán Việt hoặc một từ/cụm từ tiếng Việt tương đương và KHÔNG chứa các placeholder như {0}, {1}.
VÍ DỤ: 李洛=Lý Lạc, 学府=Học phủ, 外套=ngoại sáo, 万相之王=Vạn Tượng Chi Vương.
Nhóm 2: việt phrase
ĐỊNH NGHĨA: Là các cụm từ, thành ngữ, hoặc động từ có số lượng chữ Tiếng Trung nhỏ hơn hoặc bằng 6, thể hiện hành động, trạng thái. Chúng thường là các cụm từ cố định trong văn nói hoặc văn viết. YÊU CẦU CỦA TÔI: Chúng được dịch sang một cụm từ tiếng Việt tự nhiên, dễ hiểu cho người đọc và KHÔNG chứa các placeholder như {0}, {1}.
VÍ DỤ: 心头一动=trong lòng khẽ động, 咬牙切齿=nghiến răng nghiến lợi, 沉声说道=trầm giọng nói.
Nhóm 3: luật nhân
ĐỊNH NGHĨA: Là các mẫu câu hoặc cấu trúc có chứa các thành phần có thể thay thế (như tên người, đối tượng, số lượng), BẮT BUỘC phải có số lượng chữ tiếng Trung NHỎ HƠN 10. YÊU CẦU CỦA TÔI: Chúng phải được dịch dễ hiểu cho người đọc. Bạn cần khái quát hóa chúng bằng cách sử dụng các placeholder {0}, {1}, {2} để thay thế cho các thành phần có thể thay thế đó. KHÔNG tạo luật với các mẫu câu hoặc cấu trúc có số lượng chữ tiếng Trung LỚN HƠN hoặc BẰNG 10. KHÔNG tạo luật mà không sử dụng placeholder.
VÍ DỤ về cách tạo:
Nếu trong văn bản có câu 向李洛拱了拱手 (chắp tay với Lý Lạc), bạn cần nhận diện "Lý Lạc" là tên người, cũng là đối tượng, là một thành phần có thể thay thế và tạo ra luật: 向{0}拱了拱手=chắp tay với {0}.
Nếu có câu 一阶相师 (nhất giai Tướng Sư), bạn cần nhận diện "nhất" là số lượng và "Tướng Sư" là đối tượng, chúng là những thành phần có thể thay thế và tạo ra luật: {0}阶{1}={0} giai {1}.
Nếu có câu 一双明眸 (một đôi mắt sáng), bạn cần nhận diện "một" là số lượng và "mắt" là đối tượng, chúng là một thành phần có thể thay thế và tạo ra luật: {0}双{0}={0} đôi {1} sáng.
Nếu có câu 却见芸芸众生,筑基真人,全部面容呆滞,口中齐声发出了一声感叹(lại thấy chúng sinh, Trúc Cơ Chân Nhân, tất cả đều mặt mày ngây dại, đồng thanh phát ra một tiếng cảm thán), bạn sẽ KHÔNG tạo luật bởi vì số lượng chữ Tiếng Trung của nó là 27 lớn hơn 10. 
Bước 2: Thực hiện và định dạng đầu ra
Phân tích văn bản đầu vào, trích xuất và phân loại theo 3 nhóm trên. Sau đó, trình bày kết quả theo định dạng BẮT BUỘC sau đây:
Định dạng tổng thể: Chỉ trả về văn bản thuần túy (plain text).
Tiêu đề các phần: Phải bắt đầu bằng 3 tiêu đề chính xác:
"- tên:"
"- việt phrase:"
"- luật nhân:"
Định dạng mỗi mục: Mỗi mục trong các phần phải theo cấu trúc Tiếng Trung=Tiếng Việt.
VÍ DỤ:
- tên:
六牙白象=Lục Nha Bạch Tượng
菩提树=Bồ Đề Thụ
佛光=Phật Quang
鬼哭神嚎=Quỷ Khóc Thần Hào
- việt phrase:
难以言喻=khó mà diễn tả
消弥无形=tiêu tan vô hình
望向自己=nhìn về phía mình
- luật nhân:
以至于{0}都愣住了=khiến cho {0} cũng ngây người ra
在{0}之中=trong {0}
包括{0}在内=bao gồm cả {0}
Quy tắc viết hoa:
Trong phần - tên:, VIẾT HOA chữ cái đầu của các âm tiết trong tên riêng (ví dụ: Lý Lạc, Vạn Tượng Chi Vương). Viết thường các danh từ chung (ví dụ: ngoại sáo).
Trong phần - việt phrase: và - luật nhân:, viết thường toàn bộ kết quả dịch tiếng Việt.
QUY TẮC TỐI THƯỢNG: KHÔNG được giải thích, KHÔNG thêm ghi chú. Chỉ và chỉ trả về ba khối dữ liệu theo đúng định dạng.`;

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', loadState);
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFileDrop(e.dataTransfer.files); });
        fileInput.addEventListener('change', (e) => handleFileDrop(e.target.files));
        mainTextInput.addEventListener('input', handleManualTextInput); 
        prepareChunksBtn.addEventListener('click', handlePrepareChunks);
        startBtn.addEventListener('click', () => startProcessing(false));
        resumeBtn.addEventListener('click', () => startProcessing(true));
        saveStateBtn.addEventListener('click', () => { saveState(); alert('Đã lưu phiên làm việc!'); });
        clearStateBtn.addEventListener('click', () => { if (confirm('Bạn có chắc muốn xóa toàn bộ dữ liệu và làm mới không?')) { clearState(); } });
        
        // Standardizer Listeners
        standardizeGeneratedBtn.addEventListener('click', handleStandardizeGenerated);
        setupManualStandardizer('name');
        setupManualStandardizer('vp');
        setupManualStandardizer('rule');


        // --- State Management ---
        function saveState() {
            const state = {
                apiKeys: apiKeysInput.value, prompt: promptInput.value, mainText: fullInputText, chunks: chunksToProcess,
                outputName: outputName.value, outputVp: outputVp.value, outputRule: outputRule.value,
            };
            localStorage.setItem('geminiProcessorState', JSON.stringify(state));
        }

        function loadState() {
            const stateJSON = localStorage.getItem('geminiProcessorState');
            if (stateJSON) {
                const state = JSON.parse(stateJSON);
                apiKeysInput.value = state.apiKeys || '';
                promptInput.value = state.prompt || DEFAULT_PROMPT;
                fullInputText = state.mainText || '';
                updateInputPreview(); 
                chunksToProcess = state.chunks || [];
                outputName.value = state.outputName || '';
                outputVp.value = state.outputVp || '';
                outputRule.value = state.outputRule || '';
                updateChunkListUI();
                updateProgressCounter();
            } else { promptInput.value = DEFAULT_PROMPT; }
        }

        function clearState() {
            localStorage.removeItem('geminiProcessorState');
            chunksToProcess = []; isProcessing = false;
            fullInputText = ''; 
            apiKeysInput.value = ''; promptInput.value = DEFAULT_PROMPT;
            outputName.value = ''; outputVp.value = ''; outputRule.value = '';
            fileInput.value = '';
            reviewName.value = ''; reviewVp.value = ''; reviewRule.value = '';
            
            updateInputPreview(); 

             ['name', 'vp', 'rule'].forEach(type => {
                const container = document.getElementById(`standardizer-${type}`);
                container.querySelector('textarea:first-of-type').value = '';
                const outputTextarea = container.querySelector('textarea:last-of-type');
                outputTextarea.value = '';
                outputTextarea.fullContent = '';
                container.querySelector('.file-list').innerHTML = '';
                container.fileData = [];
            });

            updateChunkListUI(); updateProgressCounter();
        }

        // --- File & Chunk Handling ---
        function updateInputPreview() {
            const fullLength = fullInputText.length;
            if (fullLength > INPUT_PREVIEW_LENGTH) {
                mainTextInput.value = fullInputText.substring(0, INPUT_PREVIEW_LENGTH) +
                    `\n\n... (Và còn ${fullLength - INPUT_PREVIEW_LENGTH} ký tự nữa. Toàn bộ nội dung đã được lưu để xử lý.)`;
            } else {
                mainTextInput.value = fullInputText;
            }
            totalInputChars.textContent = fullLength.toLocaleString('vi-VN');
        }

        function handleManualTextInput() {
            fullInputText = mainTextInput.value;
            totalInputChars.textContent = fullInputText.length.toLocaleString('vi-VN');
        }

        async function handleFileDrop(files) {
            let initialSeparator = fullInputText ? `\n\n--- Nội dung từ file: ` : `--- Nội dung từ file: `;
            for (const file of files) {
                try {
                    const content = await readFileAsText(file);
                    fullInputText += `${initialSeparator}${file.name} ---\n\n${content}`;
                    initialSeparator = `\n\n--- Nội dung từ file: `;
                } catch(e) { alert(`Không thể đọc file: ${file.name}`); }
            }
            updateInputPreview();
        }
        
        function handlePrepareChunks() {
            const separatorText = separatorInput.value.replace(/\\n/g, '\n');
            const mergeCount = parseInt(mergeCountInput.value, 10) || 1;

            if (!separatorText) { alert('Ký tự tách đoạn không được để trống.'); return; }
            if (!fullInputText.trim()) { alert('Không có văn bản nào để tách.'); return; }

            const initialChunks = fullInputText.split(separatorText)
                .map(content => content.trim())
                .filter(content => content.length >= 100);

            const totalInitialChunks = initialChunks.length;
            if (totalInitialChunks === 0) {
                alert(`Không tìm thấy đoạn nào có độ dài trên 100 ký tự để xử lý.`);
                return;
            }

            const groupedContent = [];
            if (mergeCount > 1) {
                for (let i = 0; i < totalInitialChunks; i += mergeCount) {
                    const group = initialChunks.slice(i, i + mergeCount);
                    groupedContent.push(group.join(separatorText));
                }
            } else {
                groupedContent.push(...initialChunks);
            }

            chunksToProcess = groupedContent.map((content, index) => {
                let id;
                if (mergeCount > 1) {
                    const startNum = index * mergeCount + 1;
                    const endNum = Math.min((index + 1) * mergeCount, totalInitialChunks);
                    id = `Đoạn ${startNum}-${endNum}`;
                } else {
                    id = `Đoạn ${index + 1}`;
                }
                return { id, content, status: 'pending' };
            });

            const skippedCount = fullInputText.split(separatorText).length - totalInitialChunks;
            updateChunkListUI();
            updateProgressCounter();
            alert(`Đã chuẩn bị ${chunksToProcess.length} đoạn lớn để xử lý (từ ${totalInitialChunks} đoạn nhỏ, gộp ${mergeCount} đoạn một). Bỏ qua ${skippedCount} đoạn có độ dài dưới 100 ký tự.`);
        }

        function updateChunkListUI() {
            chunkListElem.innerHTML = '';
            chunksToProcess.forEach(chunkData => {
                const li = document.createElement('li');
                li.className = `status-${chunkData.status}`;
                li.textContent = `${chunkData.id} (${chunkData.content.substring(0, 50)}...)`;
                chunkListElem.appendChild(li);
            });
        }
        
        function updateProgressCounter() {
            const successCount = chunksToProcess.filter(c => c.status === 'success').length;
            const totalCount = chunksToProcess.length;
            progressCounter.textContent = totalCount > 0 ? `(${successCount} / ${totalCount})` : '';
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file);
            });
        }

        // --- Core Gemini Processing Logic ---
        async function startProcessing(resumeOnly) {
            if (isProcessing) { alert('Đang trong quá trình xử lý, vui lòng đợi...'); return; }
            const apiKeys = apiKeysInput.value.trim().split('\n').filter(k => k);
            if (apiKeys.length === 0) { alert('Vui lòng nhập ít nhất một API Key.'); return; }
            let queue = resumeOnly ? chunksToProcess.filter(c => c.status === 'failed') : chunksToProcess.slice();
            if (resumeOnly) { queue.forEach(c => c.status = 'pending'); }
            if (queue.length === 0) { alert(resumeOnly ? 'Không có đoạn lỗi nào để xử lý lại.' : 'Không có đoạn nào để xử lý. Vui lòng tách đoạn trước.'); return; }
            isProcessing = true; startBtn.disabled = true; resumeBtn.disabled = true;
            for (const chunkData of queue) {
                chunkData.status = 'processing';
                updateChunkListUI();
                try {
                    const resultText = await callGeminiAPI(chunkData.content, apiKeys, promptInput.value);
                    parseAndAppendResult(resultText, chunkData.id);
                    chunkData.status = 'success';
                } catch (error) {
                    console.error(`Lỗi khi xử lý ${chunkData.id}:`, error);
                    chunkData.status = 'failed';
                }
                updateChunkListUI(); updateProgressCounter();
            }
            isProcessing = false; startBtn.disabled = false; resumeBtn.disabled = false;
            saveState(); alert('Đã xử lý xong!');
        }
        
        async function callGeminiAPI(content, apiKeys, prompt, keyIndex = 0) {
            if (keyIndex >= apiKeys.length) { throw new Error("Tất cả API Key đều đã thất bại."); }
            const apiKey = apiKeys[keyIndex];
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
            const body = {
                "contents": [{ "parts": [{ "text": `${prompt}\n\n---\n\n${content}` }] }],
                "generationConfig": { "temperature": 1, "topK": 1, "topP": 0.9, "maxOutputTokens": 65536 },
                "safetySettings": [ { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" }, { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" }, { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" }, { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" } ]
            };
            try {
                const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
                if (response.ok) {
                    const result = await response.json();
                    if (result.candidates && result.candidates[0]) { return result.candidates[0].content.parts[0].text; }
                }
                console.warn(`API Key ${keyIndex + 1} thất bại (HTTP ${response.status} hoặc không có nội dung). Thử key tiếp theo.`);
                return await callGeminiAPI(content, apiKeys, prompt, keyIndex + 1);
            } catch (error) {
                console.warn(`Ngoại lệ với API Key ${keyIndex + 1}: ${error}. Thử key tiếp theo.`);
                return await callGeminiAPI(content, apiKeys, prompt, keyIndex + 1);
            }
        }

        function parseAndAppendResult(geminiText, sourceChunkId) {
            const separator = `\n\n--- Kết quả từ: ${sourceChunkId} ---\n\n`;
            const nameMarker = "- tên:"; const vpMarker = "- việt phrase:"; const ruleMarker = "- luật nhân:";
            const nameIndex = geminiText.indexOf(nameMarker); const vpIndex = geminiText.indexOf(vpMarker); const ruleIndex = geminiText.indexOf(ruleMarker);
            let nameContent = '', vpContent = '', ruleContent = '';
            if (nameIndex !== -1 && vpIndex !== -1) nameContent = geminiText.substring(nameIndex + nameMarker.length, vpIndex).trim();
            if (vpIndex !== -1 && ruleIndex !== -1) vpContent = geminiText.substring(vpIndex + vpMarker.length, ruleIndex).trim();
            if (ruleIndex !== -1) ruleContent = geminiText.substring(ruleIndex + ruleMarker.length).trim();
            if (!nameContent && !vpContent && !ruleContent) nameContent = geminiText;
            if (nameContent) outputName.value += (outputName.value ? separator : '') + nameContent;
            if (vpContent) outputVp.value += (outputVp.value ? separator : '') + vpContent;
            if (ruleContent) outputRule.value += (outputRule.value ? separator : '') + ruleContent;
        }
        
        // ================================================================
        // === LOGIC MỚI CHO CHUẨN HÓA - CẬP NHẬT LOGIC LỌC ===
        // ================================================================

        const VIETNAMESE_CHARS = 'àáâãèéêìíòóôõùúăđĩũơưạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳýỵỷỹ';
        // Regex nghiêm ngặt: không cho phép {}
        const ALLOWED_CHARS_REGEX = new RegExp(`^[\u4E00-\u9FFFa-zA-Z0-9=\\s${VIETNAMESE_CHARS}${VIETNAMESE_CHARS.toUpperCase()}]+$`);
        // Regex dễ tính: cho phép {}
        const ALLOWED_CHARS_WITH_BRACES_REGEX = new RegExp(`^[\u4E00-\u9FFFa-zA-Z0-9=\\s{}${VIETNAMESE_CHARS}${VIETNAMESE_CHARS.toUpperCase()}]+$`);

        function containsChinese(text) { return /[\u4E00-\u9FFF]/.test(text); }
        function isUpperCaseChar(char) { return char.toLowerCase() !== char && char.toUpperCase() === char; }
        function isTitleCase(text) {
            const words = text.trim().split(/\s+/);
            if (!words[0]) return true;
            return words.every(word => word.length === 0 || isUpperCaseChar(word[0]));
        }

        /**
         * Hàm chuẩn hóa nâng cao, tích hợp tất cả các bộ lọc.
         */
        function advancedStandardizeText(inputText, options) {
            if (!inputText || !inputText.trim()) return '';
            
            const uniqueEntries = new Map();
            const allLines = inputText.split('\n');
            for (const line of allLines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('---')) continue;
                const separatorIndex = trimmedLine.indexOf('=');
                if (separatorIndex === -1) continue;
                const key = trimmedLine.substring(0, separatorIndex).trim();
                const value = trimmedLine.substring(separatorIndex + 1).trim();
                if (key && !uniqueEntries.has(key)) {
                    uniqueEntries.set(key, value);
                }
            }

            const resultLines = [];
            for (const [key, value] of uniqueEntries.entries()) {
                const currentLine = `${key}=${value}`;

                if (!containsChinese(currentLine)) continue;

                // Lọc ký tự đặc biệt dựa trên các tùy chọn
                if (options.removeSpecialChars) {
                    // Chọn regex phù hợp dựa trên tùy chọn cho phép {} hay không
                    const regexToUse = options.allowCurlyBraces ? ALLOWED_CHARS_WITH_BRACES_REGEX : ALLOWED_CHARS_REGEX;
                    if (!regexToUse.test(currentLine)) {
                        continue; // Bỏ qua dòng này nếu nó chứa ký tự không được phép
                    }
                }

                if (isTitleCase(value)) {
                    resultLines.push(currentLine);
                } else {
                    resultLines.push(`${key}=${value.toLowerCase()}`);
                }
            }
            return resultLines.join('\n');
        }

        function createContentPreview(fullContent, maxLines = 200) {
            if (!fullContent) return 'Không có nội dung.';
            const lines = fullContent.split('\n');
            if (lines.length <= maxLines) return fullContent;
            
            const preview = lines.slice(0, maxLines).join('\n');
            return `${preview}\n\n--- (Hiển thị ${maxLines} trên tổng số ${lines.length} dòng) ---`;
        }

        function getStandardizeOptions() {
             return {
                removeSpecialChars: removeSpecialCharsToggle.checked,
                allowCurlyBraces: allowCurlyBracesToggle.checked
            };
        }

        function handleStandardizeGenerated() {
            const options = getStandardizeOptions();
            
            const fullResultName = advancedStandardizeText(outputName.value, options);
            reviewName.fullContent = fullResultName;
            reviewName.value = createContentPreview(fullResultName);

            const fullResultVp = advancedStandardizeText(outputVp.value, options);
            reviewVp.fullContent = fullResultVp;
            reviewVp.value = createContentPreview(fullResultVp);

            const fullResultRule = advancedStandardizeText(outputRule.value, options);
            reviewRule.fullContent = fullResultRule;
            reviewRule.value = createContentPreview(fullResultRule);

            alert('Đã chuẩn hóa xong 3 file kết quả!');
        }
        
        function setupManualStandardizer(type) {
            const container = document.getElementById(`standardizer-${type}`);
            if (!container) return;

            const inputTextArea = container.querySelector('textarea:first-of-type');
            const dropZone = container.querySelector('.drop-zone');
            const fileInput = container.querySelector('.file-input-hidden');
            const fileList = container.querySelector('.file-list');
            const standardizeBtn = container.querySelector('.button-group button');
            const outputArea = container.querySelector('.output-area');
            const outputTextArea = outputArea.querySelector('textarea');
            const copyBtn = outputArea.querySelector('.button-group button:first-child');
            const downloadBtn = outputArea.querySelector('.button-group button:last-child');
            
            container.fileData = [];

            dropZone.addEventListener('click', () => fileInput.click());
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
            dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
            fileInput.addEventListener('change', (e) => { handleFiles(e.target.files); e.target.value = ''; });

            function handleFiles(newFiles) {
                for (const file of newFiles) {
                    if (!container.fileData.some(f => f.name === file.name)) {
                        container.fileData.push({ file: file, name: file.name });
                    }
                }
                updateUI();
            }

            function updateUI() {
                fileList.innerHTML = '';
                container.fileData.forEach(f => {
                    const li = document.createElement('li');
                    li.textContent = f.name;
                    fileList.appendChild(li);
                });
            }

            standardizeBtn.addEventListener('click', async () => {
                let combinedText = inputTextArea.value;
                for (const fileData of container.fileData) {
                    try {
                        const fileContent = await readFileAsText(fileData.file);
                        combinedText += "\n" + fileContent;
                    } catch (error) { alert(`Lỗi đọc file ${fileData.name}`); }
                }
                
                const options = getStandardizeOptions();
                const fullResult = advancedStandardizeText(combinedText, options);

                outputTextArea.fullContent = fullResult;
                outputTextArea.value = createContentPreview(fullResult);
                alert(`Đã chuẩn hoá xong ${type.toUpperCase()}!`);
            });

            copyBtn.addEventListener('click', () => copyToClipboard(outputTextArea));
            downloadBtn.addEventListener('click', () => downloadAsFile(outputTextArea, `${type}_manual_std.txt`));
        }

        // --- Utility Functions (Updated) ---
        function copyToClipboard(element) {
            const textarea = (typeof element === 'string') ? document.getElementById(element) : element;
            const contentToCopy = textarea.fullContent || textarea.value;

            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = contentToCopy;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextarea);

            alert('Đã copy nội dung!');
        }

        function downloadAsFile(element, filename) {
            const textarea = (typeof element === 'string') ? document.getElementById(element) : element;
            const contentToDownload = textarea.fullContent || textarea.value;

            const blob = new Blob([contentToDownload], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
            URL.revokeObjectURL(link.href);
        }
    </script>
</body>
</html>